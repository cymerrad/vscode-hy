{
    "comment": "The foldings do not currently work the way I want them to. This may be a limitation of the way they are applied rather than the regexps in use. Nonetheless, the foldings will end on the last identically indented blank line following an s-expression. Not ideal perhaps, but it works. Also, the #illegal pattern never matches an unpaired ( as being illegal. Why?! -- Rob Rix\nOk, hopefully this grammar works better on quoted stuff now.  It may break for fancy macros, but should generally work pretty smoothly.  -- Jacob Rus\nI have attempted to get this under control but because of the way folding and indentation interact in Textmate, I am not sure if it is possible. In the meantime, I have implemented Python-style folding anchored at newlines.\nAdditionally, I have made some minor improvements to the numeric constant highlighting. Next up is square bracket expressions, I guess, but that should be trivial. -- ozy`\n",
    "fileTypes": [
        "hy"
    ],
    "keyEquivalent": "^~S",
    "name": "Hy",
    "patterns": [
        {
            "include": "#comment"
        },
        {
            "include": "#block-comment"
        },
        {
            "include": "#sexp"
        },
        {
            "include": "#string"
        },
        {
            "include": "#language-functions"
        },
        {
            "include": "#quote"
        },
        {
            "include": "#illegal"
        }
    ],
    "repository": {
        "comment": {
            "begin": "(^[ \\t]+)?(?=;)",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.whitespace.comment.leading.hy"
                }
            },
            "end": "(?!\\G)",
            "patterns": [
                {
                    "begin": ";",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.definition.comment.hy"
                        }
                    },
                    "end": "\\n",
                    "name": "comment.line.semicolon.hy"
                }
            ]
        },
        "constants": {
            "patterns": [
                {
                    "match": "True|False",
                    "name": "constant.language.boolean.hy"
                },
                {
                    "match": "(?<=[\\(\\s])((#e|#i)?[0-9]+(\\.[0-9]+)?|(#x)[0-9a-fA-F]+|(#o)[0-7]+|(#b)[01]+)(?=[\\s;()'\",\\[\\]])",
                    "name": "constant.numeric.hy"
                }
            ]
        },
        "illegal": {
            "comment": "TODO(rado) This causes issues with keyword.control.hy",
            "match": "[()\\[\\]]",
            "name": "invalid.illegal.parenthesis.hy"
        },
        "language-functions": {
            "patterns": [
                {
                    "match": "(?x)\n(?<=(\\s|\\()) # preceded by space or (\n(\n  \\.|->|->>|and|as->|assert|assoc|break|comment|cond|\n  dfor|setv|defclass|defn|\n  continue|do|doc|#doc|\n  defn/a|defmain|defmacro|defmacro/g!|defmacro!|\n  deftag|del|doto|eval-and-compile|eval-when-compile|\n  first|for|gensym|get|gfor|global|if|if\\*|if-not|\n  lif|lif-not|import|fn|fn/a|last|lfor|nonlocal|\n  not|or|print|quasiquote|quote|require|\n  rest|return|sfor|cut|raise|try|unless|\n  unpack-iterable|unpack-mapping|unquote|\n  unquote-splice|when|while|with|with/a|\n  with-decorator|#@|with-gensyms|xor|yield|yield-from\n)\n(?=(\\s|\\())\n",
                    "name": "keyword.control.hy"
                },
                {
                    "comment": "\n+, -, *, /, =, !=, >, etc. \n",
                    "match": "(?x)\n(?<=(\\s|\\()) # preceded by space or (\n( >=?|<=?|!?=|[*/+-])\n(?=(\\s|\\()) # followed by space or (\n",
                    "name": "keyword.operator.arithmetic.hy"
                },
                {
                    "match": "(?x)\n(?<=(\\s|\\()) # preceded by space or (\n(\n  #hy built in\n  .|->|->>|and|as->|assert|assoc|break|comment|\n  cond|continue|do|doc|#doc|dfor|setv|defclass|\n  defn|defn/a|defmain|defmacro|defmacro/g!|defmacro!|\n  deftag|del|doto|eval-and-compile|eval-when-compile|\n  first|for|gensym|get|gfor|global|if|if*|if-not|\n  import|fn|fn/a|last|lfor|nonlocal|not|or|print|\n  quasiquote|quote|require|rest|return|sfor|cut|raise|\n  try|unless|unpack-iterable|unpack-mapping|unquote|\n  unquote-splice|when|while|with|with/a|with-decorator|\n  with-gensyms|xor|yield|yield-from|#*|\n\n  #hy core\n  butlast|coll?|comp|complement|constantly|dec|\n  disassemble|empty?|eval|every?|exec|float?|\n  fraction|even?|identity|inc|instance?|integer?|\n  interleave|interpose|iterable?|iterator?|juxt|\n  keyword|keyword?|macroexpand|macroexpand-1|mangle|\n  merge-with|name|neg?|none?|nth|numeric?|odd?|\n  partition|pos?|second|some|string?|symbol?|zero?|\n  #hy Sequence\n  cycle|distinct|drop|drop-last|drop-while|filter|\n  flatten|iterate|read|read-str|remove|repeat|\n  repeatedly|take|take-nth|take-while|unmangle|\n  #py keyword and built-in https://docs.python.org/3/library/functions.html\n  False|None|True|as|in|is|lambda|nonlocal|not|pass|\n  abs|all|any|ascii|bin|bool|bytearray|bytes|callable|\n  chr|classmethod|compile|complex|delattr|dict|dir|divmod|\n  enumerate|eval|exec|filter|float|format|frozenset|getattr|\n  globals|hasattr|hash|help|hex|id|input|int|isinstance|issubclass|\n  iter|len|list|locals|map|max|memoryview|min|next|object|oct|open|\n  ord|pow|print|property|range|repr|reversed|round|set|setattr|slice|\n  sorted|staticmethod|str|sum|super|tuple|type|vars|zip|__import__|\n\n  # unary math operators\n  abs|acos|angle|asin|assoc|assq|assv|atan|ceiling|\n  cos|floor|round|sin|sqrt|tan|\n  (?:real|imag)-part|numerator|denominator\n\n  # other math operators\n  modulo|exp|expt|remainder|quotient|lcm|\n\n  # ports / files\n  call-with-(?:input|output)-file|\n  (?:close|current)-(?:input|output)-port|\n  with-(?:input|output)-from-file|\n  open-(?:input|output)-file|\n\n  # char-\u00abfoo\u00bb\n  char-(?:downcase|upcase|ready)|\n\n  # make-\u00abfoo\u00bb\n  make-(?:polar|promise|rectangular|string|vector)\n\n  # string-\u00abfoo\u00bb, vector-\u00abfoo\u00bb\n  string(?:-(?:append|copy|length|ref))?|\n  vector(?:-length|-ref)\n)\n(?=(\\s|\\()) # followed by space or (\n",
                    "name": "support.function.general.hy"
                }
            ]
        },
        "quote": {
            "comment": "We need to be able to quote any kind of item, which creates a tiny bit of complexity in our grammar.  It is hopefully not overwhelming complexity.\nNote: the first two matches are special cases.  quoted symbols, and quoted empty lists are considered constant.other\n",
            "patterns": [
                {
                    "captures": {
                        "1": {
                            "name": "punctuation.section.quoted.symbol.hy"
                        }
                    },
                    "match": "(?x)\n('')\\s*\n([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)\n",
                    "name": "constant.other.symbol.hy"
                },
                {
                    "captures": {
                        "1": {
                            "name": "punctuation.section.quoted.empty-list.hy"
                        },
                        "2": {
                            "name": "meta.expression.hy"
                        },
                        "3": {
                            "name": "punctuation.section.expression.begin.hy"
                        },
                        "4": {
                            "name": "punctuation.section.expression.end.hy"
                        }
                    },
                    "match": "(?x)\n('')\\s*\n((\\()\\s*(\\)))\n",
                    "name": "constant.other.empty-list.schem"
                },
                {
                    "begin": "(')\\s*",
                    "beginCaptures": {
                        "1": {
                            "name": "punctuation.section.quoted.hy"
                        }
                    },
                    "comment": "quoted double-quoted string or s-expression",
                    "end": "(?=[\\s()])|(?<=\\n)",
                    "name": "string.other.quoted-object.hy",
                    "patterns": [
                        {
                            "include": "#quoted"
                        }
                    ]
                }
            ]
        },
        "quote-sexp": {
            "begin": "(?<=\\()\\s*(quote)\\b\\s*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.quote.hy"
                }
            },
            "comment": "Something quoted with (quote \u00abthing\u00bb).  In this case \u00abthing\u00bb will not be evaluated, so we are considering it a string.\n",
            "contentName": "string.other.quote.hy",
            "end": "(?=[\\s)])|(?<=\\n)",
            "patterns": [
                {
                    "include": "#quoted"
                }
            ]
        },
        "quoted": {
            "patterns": [
                {
                    "include": "#string"
                },
                {
                    "begin": "(\\()",
                    "beginCaptures": {
                        "1": {
                            "name": "punctuation.section.expression.begin.hy"
                        }
                    },
                    "end": "(\\))",
                    "endCaptures": {
                        "1": {
                            "name": "punctuation.section.expression.end.hy"
                        }
                    },
                    "name": "meta.expression.hy",
                    "patterns": [
                        {
                            "include": "#quoted"
                        }
                    ]
                },
                {
                    "include": "#quote"
                },
                {
                    "include": "#illegal"
                }
            ]
        },
        "sexp": {
            "begin": "(\\()",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.section.expression.begin.hy"
                }
            },
            "end": "(\\))(\\n)?",
            "endCaptures": {
                "1": {
                    "name": "punctuation.section.expression.end.hy"
                },
                "2": {
                    "name": "meta.after-expression.hy"
                }
            },
            "name": "meta.expression.hy",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "begin": "(?x)\n(?<=\\()       # preceded by (\n(defn)   # defn\n(\\s+)     #function name\n([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)\\s+\n\\[ # list of parameters\n((?:\n([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n\\s+\n)*(?:\n([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n)?)\n(\\])\n",
                    "captures": {
                        "1": {
                            "name": "keyword.control.hy"
                        },
                        "2": {
                            "name": "punctuation.definition.function.hy"
                        },
                        "3": {
                            "name": "entity.name.function.hy"
                        },
                        "4": {
                            "name": "variable.parameter.function.hy"
                        },
                        "7": {
                            "name": "punctuation.definition.function.hy"
                        }
                    },
                    "end": "(?=\\))",
                    "name": "meta.declaration.procedure.hy",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#sexp"
                        },
                        {
                            "include": "#illegal"
                        }
                    ]
                },
                {
                    "begin": "(?x)\n(?<=\\() # preceded by (\n(fn)\\s+\n(\\[) # opening paren\n((?:\n([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n\\s+\n)*(?:\n  ([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n)?)\n(\\]) # closing paren\n",
                    "captures": {
                        "1": {
                            "name": "keyword.control.hy"
                        },
                        "2": {
                            "name": "punctuation.definition.variable.hy"
                        },
                        "3": {
                            "name": "variable.parameter.hy"
                        },
                        "6": {
                            "name": "punctuation.definition.variable.hy"
                        }
                    },
                    "comment": "Not sure this one is quite correct.  That \\s* is particularly troubling\n",
                    "end": "(?=\\))",
                    "name": "meta.declaration.procedure.hy",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#sexp"
                        },
                        {
                            "include": "#illegal"
                        }
                    ]
                },
                {
                    "begin": "(?<=\\()(defn)\\s([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)\\s*.*?",
                    "captures": {
                        "1": {
                            "name": "keyword.control.hy"
                        },
                        "2": {
                            "name": "variable.other.hy"
                        }
                    },
                    "end": "(?=\\))",
                    "name": "meta.declaration.variable.hy",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#sexp"
                        },
                        {
                            "include": "#illegal"
                        }
                    ]
                },
                {
                    "include": "#quote-sexp"
                },
                {
                    "include": "#quote"
                },
                {
                    "include": "#language-functions"
                },
                {
                    "include": "#string"
                },
                {
                    "include": "#constants"
                },
                {
                    "match": "(?<=[\\(\\s])(#\\\\)(space|newline|tab)(?=[\\s\\)])",
                    "name": "constant.character.named.hy"
                },
                {
                    "match": "(?<=[\\(\\s])(#\\\\)x[0-9A-F]{2,4}(?=[\\s\\)])",
                    "name": "constant.character.hex-literal.hy"
                },
                {
                    "match": "(?<=[\\(\\s])(#\\\\).(?=[\\s\\)])",
                    "name": "constant.character.escape.hy"
                },
                {
                    "comment": "the . in (a . b) which conses together two elements a and b. (a b c) == (a . (b . (c . nil)))\n",
                    "match": "(?<=[ ()])\\.(?=[ ()])",
                    "name": "punctuation.separator.cons.hy"
                },
                {
                    "include": "#sexp"
                },
                {
                    "include": "#illegal"
                }
            ]
        },
        "string": {
            "begin": "(\")",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.definition.string.begin.hy"
                }
            },
            "end": "(\")",
            "endCaptures": {
                "1": {
                    "name": "punctuation.definition.string.end.hy"
                }
            },
            "name": "string.quoted.double.hy",
            "patterns": [
                {
                    "match": "\\.",
                    "name": "constant.character.escape.hy"
                }
            ]
        }
    },
    "scopeName": "source.hy",
    "uuid": "BEEFBEEF-BEEF-BEEF-BEEF-BEEFBEEFBEEF"
}