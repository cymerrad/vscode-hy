{
    "comment": "\n\t\tThe foldings do not currently work the way I want them to. This\n\t\tmay be a limitation of the way they are applied rather than the\n\t\tregexps in use. Nonetheless, the foldings will end on the last\n\t\tidentically indented blank line following an s-expression. Not\n\t\tideal perhaps, but it works. Also, the #illegal pattern never\n\t\tmatches an unpaired ( as being illegal. Why?! -- Rob Rix\n\t\t\n\t\tOk, hopefully this grammar works better on quoted stuff now.  It\n\t\tmay break for fancy macros, but should generally work pretty\n\t\tsmoothly.  -- Jacob Rus\n\t\t\n\t\tI have attempted to get this under control but because of the way folding\n\t\tand indentation interact in Textmate, I am not sure if it is possible. In the\n\t\tmeantime, I have implemented Python-style folding anchored at newlines.\n\t\tAdditionally, I have made some minor improvements to the numeric constant\n\t\thighlighting. Next up is square bracket expressions, I guess, but that\n\t\tshould be trivial. -- ozy`\n\t",
    "fileTypes": [
        "hy"
    ],
    "keyEquivalent": "^~S",
    "name": "Hy",
    "patterns": [
        {
            "include": "#comment"
        },
        {
            "include": "#block-comment"
        },
        {
            "include": "#sexp"
        },
        {
            "include": "#string"
        },
        {
            "include": "#language-functions"
        },
        {
            "include": "#quote"
        },
        {
            "include": "#illegal"
        }
    ],
    "repository": {
        "comment": {
            "begin": "(^[ \\t]+)?(?=;)",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.whitespace.comment.leading.hy"
                }
            },
            "end": "(?!\\G)",
            "patterns": [
                {
                    "begin": ";",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.definition.comment.hy"
                        }
                    },
                    "end": "\\n",
                    "name": "comment.line.semicolon.hy"
                }
            ]
        },
        "block-comment": {
            "begin": "\\#\\|",
            "contentName": "comment",
            "end": "\\|\\#",
            "name": "comment",
            "patterns": [
                {
                    "include": "#block-comment",
                    "name": "comment"
                }
            ]
        },
        "constants": {
            "patterns": [
                {
                    "match": "#[t|f]",
                    "name": "constant.language.boolean.hy"
                },
                {
                    "match": "(?<=[\\(\\s])((#e|#i)?[0-9]+(\\.[0-9]+)?|(#x)[0-9a-fA-F]+|(#o)[0-7]+|(#b)[01]+)(?=[\\s;()'\",\\[\\]])",
                    "name": "constant.numeric.hy"
                }
            ]
        },
        "illegal": {
            "match": "[()\\[\\]]",
            "name": "invalid.illegal.parenthesis.hy"
        },
        "language-functions": {
            "patterns": [
                {
                    "match": "(?x)\n\t\t\t\t\t\t(?<=(\\s|\\(|\\[)) # preceded by space or ( \n\t\t\t\t\t\t( do|or|and|else|quasiquote|begin|if|case|set!|\n\t\t\t\t\t\t  cond|let|unquote|define|let\\*|unquote-splicing|delay|\n\t\t\t\t\t\t  letrec|\n\t\t\t\t\t\t  #hy \n\t\t\t\t\t\t  =|!=|>=|<=|>|<|\n\t\t\t\t\t\t  .|->|->>|and|as->|assert|assoc|break|comment|cond|\n\t\t\t\t\t\t  dfor|setv|defclass|defn|\n\t\t\t\t\t\t  continue|do|doc|#doc|\n\t\t\t\t\t\t  defn/a|defmain|defmacro|defmacro/g!|defmacro!|\n\t\t\t\t\t\t  deftag|del|doto|eval-and-compile|eval-when-compile|\n\t\t\t\t\t\t  first|for|gensym|get|gfor|global|if|if\\*|if-not|\n\t\t\t\t\t\t  lif|lif-not|import|fn|fn/a|last|lfor|nonlocal|\n\t\t\t\t\t\t  not|or|print|quasiquote|quote|require|\n\t\t\t\t\t\t  rest|return|sfor|cut|raise|try|unless|\n\t\t\t\t\t\t  unpack-iterable|unpack-mapping|unquote|\n\t\t\t\t\t\t  unquote-splice|when|while|with|with/a|\n\t\t\t\t\t\t  with-decorator|#@|with-gensyms|xor|yield|yield-from\n\t\t\t\t\t\t  )\n\t\t\t\t\t\t(?=(\\s|\\())",
                    "name": "keyword.control.hy"
                },
                {
                    "comment": "\n\t\t\t\t\t\tThese functions run a test, and return a boolean\n\t\t\t\t\t\tanswer.\n\t\t\t\t\t",
                    "match": "(?x)\n\t\t\t\t\t\t(?<=(\\s|\\()) # preceded by space or (\n\t\t\t\t\t\t( char-alphabetic|char-lower-case|char-numeric|\n\t\t\t\t\t\t  char-ready|char-upper-case|char-whitespace|\n\t\t\t\t\t\t  (?:char|string)(?:-ci)?(?:=|<=?|>=?)|\n\t\t\t\t\t\t  atom|boolean|bound-identifier=|char|complex|\n\t\t\t\t\t\t  identifier|integer|symbol|free-identifier=|inexact|\n\t\t\t\t\t\t  eof-object|exact|list|(?:input|output)-port|pair|\n\t\t\t\t\t\t  real|rational|zero|vector|negative|odd|null|string|\n\t\t\t\t\t\t  eq|equal|eqv|even|number|positive|procedure\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(\\?)\t\t# name ends with ? sign\n\t\t\t\t\t\t(?=(\\s|\\()) # followed by space or (\n\t\t\t\t\t",
                    "name": "support.function.boolean-test.hy"
                },
                {
                    "comment": "\n\t\t\t\t\t\tThese functions change one type into another.\n\t\t\t\t\t",
                    "match": "(?x)\n\t\t\t\t\t\t(?<=(\\s|\\()) # preceded by space or (\n\t\t\t\t\t\t( char->integer|exact->inexact|inexact->exact|\n\t\t\t\t\t\t  integer->char|symbol->string|list->vector|\n\t\t\t\t\t\t  list->string|identifier->symbol|vector->list|\n\t\t\t\t\t\t  string->list|string->number|string->symbol|\n\t\t\t\t\t\t  number->string\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(?=(\\s|\\()) # followed by space or (\t\t\t\t\t\n\t\t\t\t\t",
                    "name": "support.function.convert-type.hy"
                },
                {
                    "comment": "\n\t\t\t\t\t\tThese functions are potentially dangerous because\n\t\t\t\t\t\tthey have side-effects which could affect other\n\t\t\t\t\t\tparts of the program.\n\t\t\t\t\t",
                    "match": "(?x)\n\t\t\t\t\t\t(?<=(\\s|\\()) # preceded by space or (\n\t\t\t\t\t\t( set-(?:car|cdr)|\t\t\t\t # set car/cdr\n\t\t\t\t\t\t  (?:vector|string)-(?:fill|set) # fill/set string/vector\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(!)\t\t\t# name ends with ! sign\n\t\t\t\t\t\t(?=(\\s|\\()) # followed by space or (\n\t\t\t\t\t",
                    "name": "support.function.with-side-effects.hy"
                },
                {
                    "comment": "\n\t\t\t\t\t\t+, -, *, /, =, >, etc. \n\t\t\t\t\t",
                    "match": "(?x)\n\t\t\t\t\t\t(?<=(\\s|\\()) # preceded by space or (\n\t\t\t\t\t\t( >=?|<=?|=|[*/+-])\n\t\t\t\t\t\t(?=(\\s|\\()) # followed by space or (\n\t\t\t\t\t\t",
                    "name": "keyword.operator.arithmetic.hy"
                },
                {
                    "match": "(?x)\n\t\t\t\t\t\t(?<=(\\s|\\()) # preceded by space or (\n\t\t\t\t\t\t( \n\t\t\t\t\t\t  #hy build in\n\t\t\t\t\t\t  .|->|->>|and|as->|assert|assoc|break|comment|\n\t\t\t\t\t\t  cond|continue|do|doc|#doc|dfor|setv|defclass|\n\t\t\t\t\t\t  defn|defn/a|defmain|defmacro|defmacro/g!|defmacro!|\n\t\t\t\t\t\t  deftag|del|doto|eval-and-compile|eval-when-compile|\n\t\t\t\t\t\t  first|for|gensym|get|gfor|global|if|if*|if-not|\n\t\t\t\t\t\t  import|fn|fn/a|last|lfor|nonlocal|not|or|print|\n\t\t\t\t\t\t  quasiquote|quote|require|rest|return|sfor|cut|raise|\n\t\t\t\t\t\t  try|unless|unpack-iterable|unpack-mapping|unquote|\n\t\t\t\t\t\t  unquote-splice|when|while|with|with/a|with-decorator|\n\t\t\t\t\t\t  with-gensyms|xor|yield|yield-from|#*|\n\t\t\t\t\t\t  \n\t\t\t\t\t      #hy core\n\t\t\t\t\t\t  butlast|coll?|comp|complement|constantly|dec|\n\t\t\t\t\t\t  disassemble|empty?|eval|every?|exec|float?|\n\t\t\t\t\t\t  fraction|even?|identity|inc|instance?|integer?|\n\t\t\t\t\t\t  interleave|interpose|iterable?|iterator?|juxt|\n\t\t\t\t\t\t  keyword|keyword?|macroexpand|macroexpand-1|mangle|\n\t\t\t\t\t\t  merge-with|name|neg?|none?|nth|numeric?|odd?|\n\t\t\t\t\t\t  partition|pos?|second|some|string?|symbol?|zero?|\n\t\t\t\t\t\t  #hy Sequence\n\t\t\t\t\t\t  cycle|distinct|drop|drop-last|drop-while|filter|\n\t\t\t\t\t\t  flatten|iterate|read|read-str|remove|repeat|\n\t\t\t\t\t\t  repeatedly|take|take-nth|take-while|unmangle|\n\n\t\t\t\t\t\t  #py keyword and built-in https://docs.python.org/3/library/functions.html\n\t\t\t\t\t\t  False|None|True|as|in|is|lambda|nonlocal|not|pass|\n\t\t\t\t\t\t  abs|all|any|ascii|bin|bool|bytearray|bytes|callable|\n\t\t\t\t\t\t  chr|classmethod|compile|complex|delattr|dict|dir|divmod|\n\t\t\t\t\t\t  enumerate|eval|exec|filter|float|format|frozenset|getattr|\n\t\t\t\t\t\t  globals|hasattr|hash|help|hex|id|input|int|isinstance|issubclass|\n\t\t\t\t\t\t  iter|len|list|locals|map|max|memoryview|min|next|object|oct|open|\n\t\t\t\t\t\t  ord|pow|print|property|range|repr|reversed|round|set|setattr|slice|\n\t\t\t\t\t\t  sorted|staticmethod|str|sum|super|tuple|type|vars|zip|__import__|\n                          \n\t\t\t\t\t\t  # unary math operators\n\t\t\t\t\t\t  abs|acos|angle|asin|assoc|assq|assv|atan|ceiling|\n\t\t\t\t\t\t  cos|floor|round|sin|sqrt|tan|\n\t\t\t\t\t\t  (?:real|imag)-part|numerator|denominator\n                          \n\t\t\t\t\t\t  # other math operators\n\t\t\t\t\t\t  modulo|exp|expt|remainder|quotient|lcm|\n                          \n\t\t\t\t\t\t  # ports / files\n\t\t\t\t\t\t  call-with-(?:input|output)-file|\n\t\t\t\t\t\t  (?:close|current)-(?:input|output)-port|\n\t\t\t\t\t\t  with-(?:input|output)-from-file|\n\t\t\t\t\t\t  open-(?:input|output)-file|\n\t\t\t\t\t\t  \n\t\t\t\t\t\t  # char-\u00abfoo\u00bb\n\t\t\t\t\t\t  char-(?:downcase|upcase|ready)|\n\t\t\t\t\t\t  \n\t\t\t\t\t\t  # make-\u00abfoo\u00bb\n\t\t\t\t\t\t  make-(?:polar|promise|rectangular|string|vector)\n\t\t\t\t\t\t  \n\t\t\t\t\t\t  # string-\u00abfoo\u00bb, vector-\u00abfoo\u00bb\n\t\t\t\t\t\t  string(?:-(?:append|copy|length|ref))?|\n\t\t\t\t\t\t  vector(?:-length|-ref)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(?=(\\s|\\()) # followed by space or (\n\t\t\t\t\t",
                    "name": "support.function.general.hy"
                }
            ]
        },
        "quote": {
            "comment": "\n\t\t\t\tWe need to be able to quote any kind of item, which creates\n\t\t\t\ta tiny bit of complexity in our grammar.  It is hopefully\n\t\t\t\tnot overwhelming complexity.\n\t\t\t\t\n\t\t\t\tNote: the first two matches are special cases.  quoted\n\t\t\t\tsymbols, and quoted empty lists are considered constant.other\n\t\t\t\t\n\t\t\t",
            "patterns": [
                {
                    "captures": {
                        "1": {
                            "name": "punctuation.section.quoted.symbol.hy"
                        }
                    },
                    "match": "(?x)\n\t\t\t\t\t\t(')\\s*\n\t\t\t\t\t\t([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)\n\t\t\t\t\t",
                    "name": "constant.other.symbol.hy"
                },
                {
                    "captures": {
                        "1": {
                            "name": "punctuation.section.quoted.empty-list.hy"
                        },
                        "2": {
                            "name": "meta.expression.hy"
                        },
                        "3": {
                            "name": "punctuation.section.expression.begin.hy"
                        },
                        "4": {
                            "name": "punctuation.section.expression.end.hy"
                        }
                    },
                    "match": "(?x)\n\t\t\t\t\t\t(')\\s*\n\t\t\t\t\t\t((\\()\\s*(\\)))\n\t\t\t\t\t",
                    "name": "constant.other.empty-list.schem"
                },
                {
                    "begin": "(')\\s*",
                    "beginCaptures": {
                        "1": {
                            "name": "punctuation.section.quoted.hy"
                        }
                    },
                    "comment": "quoted double-quoted string or s-expression",
                    "end": "(?=[\\s()])|(?<=\\n)",
                    "name": "string.other.quoted-object.hy",
                    "patterns": [
                        {
                            "include": "#quoted"
                        }
                    ]
                }
            ]
        },
        "quote-sexp": {
            "begin": "(?<=\\()\\s*(quote)\\b\\s*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.quote.hy"
                }
            },
            "comment": "\n\t\t\t\tSomething quoted with (quote \u00abthing\u00bb).  In this case \u00abthing\u00bb\n\t\t\t\twill not be evaluated, so we are considering it a string.\n\t\t\t",
            "contentName": "string.other.quote.hy",
            "end": "(?=[\\s)])|(?<=\\n)",
            "patterns": [
                {
                    "include": "#quoted"
                }
            ]
        },
        "quoted": {
            "patterns": [
                {
                    "include": "#string"
                },
                {
                    "begin": "(\\()",
                    "beginCaptures": {
                        "1": {
                            "name": "punctuation.section.expression.begin.hy"
                        }
                    },
                    "end": "(\\))",
                    "endCaptures": {
                        "1": {
                            "name": "punctuation.section.expression.end.hy"
                        }
                    },
                    "name": "meta.expression.hy",
                    "patterns": [
                        {
                            "include": "#quoted"
                        }
                    ]
                },
                {
                    "include": "#quote"
                },
                {
                    "include": "#illegal"
                }
            ]
        },
        "sexp": {
            "begin": "(\\()",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.section.expression.begin.hy"
                }
            },
            "end": "(\\))(\\n)?",
            "endCaptures": {
                "1": {
                    "name": "punctuation.section.expression.end.hy"
                },
                "2": {
                    "name": "meta.after-expression.hy"
                }
            },
            "name": "meta.expression.hy",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "begin": "(?x)\n\t\t\t\t\t\t(?<=\\()       # preceded by (\n\t\t\t\t\t\t(defn)   # defn\n\t\t\t\t\t\t(\\s+)     #function name     \n\t\t\t\t\t\t  ([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)\\s+\n\t\t\t\t\t\t\\[ # list of parameters\n\t\t\t\t\t\t\t((?:\n\t\t\t\t\t\t\t([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n\t\t\t\t\t\t\t\\s+\n\t\t\t\t\t\t\t)*(?:\n\t\t\t\t\t\t\t([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n\t\t\t\t\t\t\t)?)\n\t\t\t\t\t\t(\\])\n\t\t\t\t\t",
                    "captures": {
                        "1": {
                            "name": "keyword.control.hy"
                        },
                        "2": {
                            "name": "punctuation.definition.function.hy"
                        },
                        "3": {
                            "name": "entity.name.function.hy"
                        },
                        "4": {
                            "name": "variable.parameter.function.hy"
                        },
                        "7": {
                            "name": "punctuation.definition.function.hy"
                        }
                    },
                    "end": "(?=\\))",
                    "name": "meta.declaration.procedure.hy",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#sexp"
                        },
                        {
                            "include": "#illegal"
                        }
                    ]
                },
                {
                    "begin": "(?x)\n\t\t\t\t\t\t(?<=\\() # preceded by (\n\t\t\t\t\t\t(fn)\\s+\n\t\t\t\t\t\t(\\[) # opening paren\n\t\t\t\t\t\t((?:\n\t\t\t\t\t\t  ([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n\t\t\t\t\t\t  \\s+\n\t\t\t\t\t\t)*(?:\n\t\t\t\t\t\t  ([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n\t\t\t\t\t\t)?)\n\t\t\t\t\t\t(\\]) # closing paren\n\t\t\t\t\t",
                    "captures": {
                        "1": {
                            "name": "keyword.control.hy"
                        },
                        "2": {
                            "name": "punctuation.definition.variable.hy"
                        },
                        "3": {
                            "name": "variable.parameter.hy"
                        },
                        "6": {
                            "name": "punctuation.definition.variable.hy"
                        }
                    },
                    "comment": "\n\t\t\t\t\t\tNot sure this one is quite correct.  That \\s* is\n\t\t\t\t\t\tparticularly troubling\n\t\t\t\t\t",
                    "end": "(?=\\))",
                    "name": "meta.declaration.procedure.hy",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#sexp"
                        },
                        {
                            "include": "#illegal"
                        }
                    ]
                },
                {
                    "begin": "(?<=\\()(defn)\\s([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)\\s*.*?",
                    "captures": {
                        "1": {
                            "name": "keyword.control.hy"
                        },
                        "2": {
                            "name": "variable.other.hy"
                        }
                    },
                    "end": "(?=\\))",
                    "name": "meta.declaration.variable.hy",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#sexp"
                        },
                        {
                            "include": "#illegal"
                        }
                    ]
                },
                {
                    "include": "#quote-sexp"
                },
                {
                    "include": "#quote"
                },
                {
                    "include": "#language-functions"
                },
                {
                    "include": "#string"
                },
                {
                    "include": "#constants"
                },
                {
                    "match": "(?<=[\\(\\s])(#\\\\)(space|newline|tab)(?=[\\s\\)])",
                    "name": "constant.character.named.hy"
                },
                {
                    "match": "(?<=[\\(\\s])(#\\\\)x[0-9A-F]{2,4}(?=[\\s\\)])",
                    "name": "constant.character.hex-literal.hy"
                },
                {
                    "match": "(?<=[\\(\\s])(#\\\\).(?=[\\s\\)])",
                    "name": "constant.character.escape.hy"
                },
                {
                    "comment": "\n\t\t\t\t\t\tthe . in (a . b) which conses together two elements\n\t\t\t\t\t\ta and b. (a b c) == (a . (b . (c . nil)))\n\t\t\t\t\t",
                    "match": "(?<=[ ()])\\.(?=[ ()])",
                    "name": "punctuation.separator.cons.hy"
                },
                {
                    "include": "#sexp"
                },
                {
                    "include": "#illegal"
                }
            ]
        },
        "string": {
            "begin": "(\")",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.definition.string.begin.hy"
                }
            },
            "end": "(\")",
            "endCaptures": {
                "1": {
                    "name": "punctuation.definition.string.end.hy"
                }
            },
            "name": "string.quoted.double.hy",
            "patterns": [
                {
                    "match": "\\\\.",
                    "name": "constant.character.escape.hy"
                }
            ]
        }
    },
    "scopeName": "source.hy",
    "uuid": "3EC2CFD0-909C-4692-AC29-1A60ADBC161E"
}